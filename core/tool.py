import re
import inspect
from abc import ABC, abstractmethod
from pydantic import BaseModel
from typing import Dict, Any, List, Optional, Callable, get_type_hints

def tool_action(name: str = None, description: str = None):
    def decorator(func: Callable):
        func._is_tool_action = True
        func._tool_name = name
        func._tool_description = description
        return func
    return decorator

class ToolParameter(BaseModel):
    name: str
    type: str
    description: str
    required: bool = True
    default: Any = None

class Tool(ABC):
    def __init__(
        self, 
        name: str, 
        description: str, 
        expandable: bool = False
    ):
        self.name = name
        self.description = description
        self.expandable = expandable

    @abstractmethod
    def run(self, parameters: Dict[str, Any]) -> str:
        pass

    @abstractmethod
    def get_parameters(self) -> List[ToolParameter]:
        pass

    def get_expanded_tools(self) -> Optional[List["Tool"]]:
        if not self.expandable:
            return None
        tools = []
        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            if hasattr(method, "_is_tool_action"):
                tool = AutoGeneratedTool(
                    parent=self,
                    method=method,
                    name=method._tool_name,
                    description=method._tool_description
                )
                tools.append(tool)
        return tools if tools else None

    def validate_parameters(self, parameters: Dict[str, Any]) -> bool:
        required_params = [p.name for p in self.get_parameters() if p.required]
        return all(param in parameters for param in required_params)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description,
            "parameters": [param.dict() for param in self.get_parameters()]
        }

    def to_openai_schema(self) -> Dict[str, Any]:
        parameters = self.get_parameters()
        properties = {}
        required = []
        for param in parameters:
            prop = {
                "type": param.type,
                "description": param.description
            }
            if param.default is not None:
                prop["description"] = f"{param.description}(default {param.default})"
            if param.type == "array":
                prop["items"] = {"type": "string"}
            properties[param.name] = prop
            if param.required:
                required.append(param.name)
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": properties,
                    "required": required
                }
            }
        }

    def __str__(self) -> str:
        return f"Tool(name={self.name})"

    def __repr__(self) -> str:
        return self.__str__()

class AutoGeneratedTool(Tool):
    def __init__(
        self, 
        parent: Tool, 
        method: Callable, 
        name: str = None, 
        description: str = None
    ):
        self.parent = parent
        self.method = method
        if name is None:
            method_name = method.__name__.lstrip('_')
            name = f"{parent.name}_{method_name}"
        if description is None:
            description = self._extract_description_from_docstring()
        super().__init__(name=name, description=description)
        self._parameters = self._parse_parameters()

    def _extract_description_from_docstring(self) -> str:
        doc = inspect.getdoc(self.method)
        if not doc:
            return f"æ‰§è¡Œ{self.method.__name__}"
        lines = doc.split('\n')
        for line in lines:
            line = line.strip()
            if line and not line.startswith("Args:") and not line.startswith("Returns:"):
                return line
        return f"æ‰§è¡Œ{self.method.__name__}"

    def _parse_parameters(self) -> List[ToolParameter]:
        sig = inspect.signature(self.method)
        type_hints = get_type_hints(self.method)
        docstring = inspect.getdoc(self.method) or ""
        param_descriptions = self._parse_param_descriptions(docstring)
        parameters = []
        for param_name, param in sig.parameters.items():
            if param_name == "self":
                continue
            param_type_hint = type_hints.get(param_name, str)
            param_type = self._python_type_to_tool_type(param_type_hint)
            required = param.default == inspect.Parameter.empty
            default = None if required else param.default
            description = param_descriptions.get(param_name, f"å‚æ•°{param_name}")
            parameters.append(ToolParameter(
                name=param_name,
                type=param_type,
                description=description,
                required=required,
                default=default
            ))
        return parameters

    def _parse_param_descriptions(self, docstring: str) -> Dict[str, str]:
        descriptions = {}
        args_match = re.search(r"Args:\s*\n(.*?)(?:\n\s*\n|Returns:|$)", docstring, re.DOTALL)
        if not args_match:
            return descriptions
        args_section = args_match.group(1)
        param_pattern = r"^\s*(\w+)(?:\s*\([^)]+\))?\s*:\s*(.+?)(?=^\s*\w+\s*(?:\([^)]+\))?\s*:|$)"
        matches = re.finditer(param_pattern, args_section, re.MULTILINE | re.DOTALL)
        for match in matches:
            param_name = match.group(1).strip()
            param_desc = match.group(2).strip()
            param_desc = re.sub(r"\s+", " ", param_desc)
            descriptions[param_name] = param_desc
        return descriptions

    def _python_type_to_tool_type(self, py_type) -> str:
        origin = getattr(py_type, "__origin__", None)
        if origin is not None:
            if origin is list:
                return "array"
            elif origin is dict:
                return "object"
        type_map = {
            str: "string",
            int: "integer",
            float: "number",
            bool: "boolean",
            list: "array",
            dict: "object",
        }
        return type_map.get(py_type, "string")

    def get_parameters(self) -> List[ToolParameter]:
        return self._parameters

    def run(self, parameters: Dict[str, Any]) -> str:
        return self.method(**parameters)

class ToolRegistry:
    def __init__(self):
        self._tools: dict[str, Tool] = {}
        self._functions: dict[str, dict[str, Any]] = {}

    def register_tool(self, tool: Tool, auto_expand: bool = True):
        if auto_expand and hasattr(tool, "expandable") and tool.expandable:
            expanded_tools = tool.get_expanded_tools()
            if expanded_tools:
                for sub_tool in expanded_tools:
                    if sub_tool.name in self._tools:
                        print(f"âš ï¸  è­¦å‘Šï¼šå·¥å…·'{sub_tool.name}'å·²å­˜åœ¨ï¼Œå°†è¢«è¦†ç›–")
                    self._tools[sub_tool.name] = sub_tool
                print(f"âœ… å·¥å…·'{tool.name}'å·²å±•å¼€ä¸º{len(expanded_tools)}ä¸ªç‹¬ç«‹å·¥å…·")
                return
        if tool.name in self._tools:
            print(f"âš ï¸  è­¦å‘Šï¼šå·¥å…·'{tool.name}'å·²å­˜åœ¨ï¼Œå°†è¢«è¦†ç›–")
        self._tools[tool.name] = tool
        print(f"âœ… å·¥å…·'{tool.name}'å·²æˆåŠŸæ³¨å†Œ")

    def register_function(self, name: str, description: str, func: Callable[[str], str]):
        if name in self._functions:
            print(f"âš ï¸  è­¦å‘Šï¼šå·¥å…·'{name}'å·²å­˜åœ¨ï¼Œå°†è¢«è¦†ç›–")
        self._functions[name] = {
            "description": description,
            "func": func
        }
        print(f"âœ… å·¥å…·'{name}'å·²æˆåŠŸæ³¨å†Œ")

    def unregister(self, name: str):
        if name in self._tools:
            del self._tools[name]
            print(f"ğŸ’€ å·¥å…·'{name}'å·²æ³¨é”€")
        elif name in self._functions:
            del self._functions[name]
            print(f"ğŸ’€ å·¥å…·'{name}'å·²æ³¨é”€")
        else:
            print(f"âš ï¸  å·¥å…·'{name}'ä¸å­˜åœ¨")

    def get_tool(self, name: str) -> Optional[Tool]:
        return self._tools.get(name)

    def get_function(self, name: str) -> Optional[Callable]:
        func_info = self._functions.get(name)
        return func_info["func"] if func_info else None

    def execute_tool(self, name: str, input_text: str) -> str:
        if name in self._tools:
            tool = self._tools[name]
            try:
                return tool.run({"input": input_text})
            except Exception as e:
                return f"â›” é”™è¯¯ï¼šæ‰§è¡Œå·¥å…·'{name}'æ—¶å‘ç”Ÿå¼‚å¸¸ï¼š{str(e)}"
        elif name in self._functions:
            func = self._functions[name]["func"]
            try:
                return func(input_text)
            except Exception as e:
                return f"â›” é”™è¯¯ï¼šæ‰§è¡Œå·¥å…·'{name}'æ—¶å‘ç”Ÿå¼‚å¸¸ï¼š{str(e)}"
        else:
            return f"â›” é”™è¯¯ï¼šæœªæ‰¾åˆ°åä¸º'{name}'çš„å·¥å…·"

    def get_tools_description(self) -> str:
        descriptions = []
        for tool in self._tools.values():
            descriptions.append(f"- {tool.name}: {tool.description}")
        for name, info in self._functions.items():
            descriptions.append(f"- {name}: {info['description']}")
        return "\n".join(descriptions) if descriptions else "æš‚æ— å¯ç”¨å·¥å…·"

    def list_tools(self) -> List[str]:
        return list(self._tools.keys()) + list(self._functions.keys())

    def get_all_tools(self) -> list[Tool]:
        return list(self._tools.values())

    def clear(self):
        self._tools.clear()
        self._functions.clear()
        print("ğŸ—‘ï¸  æ‰€æœ‰å·¥å…·å·²æ¸…ç©º")